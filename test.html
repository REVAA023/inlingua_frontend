<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  @if (showvideoContainer) {
    <!-- Video Player Section -->
    <div class="mt-3">
      <div class="d-flex justify-content-between align-items-center mb-3">
        <p class="fs-5 fw-bold">{{studentDetails.classVideoRecord.document.createdDate}} class record - Online Play</p>
        <button class="btn btn-sm btn-secondary" (click)="closeVideo()">
          <i class="bx fa-times"></i> Close
        </button>
      </div>

      <div class="row">
        <!-- Updated video container section in your HTML template -->
        <div class="col-6">
          <!-- Custom Video Player with Fullscreen Container -->
          <div #videoContainer class="video-container position-relative" [class.fullscreen-container]="isFullscreen">
            <video #videoPlayer [src]="studentDetails.classVideoRecord.document.documentContant" class="w-100 rounded"
              [class.fullscreen-video]="isFullscreen" preload="metadata" (loadeddata)="setupVideoEvents()"
              (dblclick)="onVideoDoubleClick()">
              Your browser does not support the video tag.
            </video>

            <!-- Custom Video Controls -->
            <div class="video-controls position-absolute bottom-0 start-0 end-0 bg-dark bg-opacity-75 p-2"
              [class.fullscreen-controls]="isFullscreen">
              <div class="d-flex align-items-center gap-2">
                <!-- Play/Pause Button -->
                <button class="btn btn-sm btn-dark m-0 p-1 rounded-5 d-flex align-items-center"
                  (click)="togglePlayPause()" title="Play/Pause (Spacebar)">
                  <i class="bx fs-6 text-light" [class.bx-play]="!isVideoPlaying" [class.bx-pause]="isVideoPlaying"></i>
                </button>

                <!-- Progress Bar -->
                <div class="flex-grow-1 range-container">
                  <input type="range" class="video-range" #videoRange [value]="getProgressPercentage()"
                    (input)="seekVideo($event)" min="0" max="100" title="Seek video">
                  <div class="progress-overlay" [style.width.%]="getProgressPercentage()"></div>
                </div>

                <!-- Time Display -->
                <span class="text-white small time-display">
                  {{formatTime(currentVideoTime)}} / {{formatTime(videoDuration)}}
                </span>

                <!-- Volume Control -->
                <div class="d-flex align-items-center gap-1">
                  <button class="btn btn-sm btn-dark m-0 p-1 rounded-5 d-flex align-items-center justify-content-center"
                    (click)="toggleMute()" title="Mute/Unmute">
                    <i class="bx fs-6 text-light" [class.bx-volume-full]="!isMuted && videoVolume > 0"
                      [class.bx-volume-mute]="isMuted || videoVolume === 0"></i>
                  </button>
                  <div class="range-container volume-container">
                    <input type="range" class="volume-range" #volumeRange [value]="videoVolume * 100"
                      (input)="changeVolume($event)" min="0" max="100" title="Volume">
                    <div class="progress-overlay" [style.width.%]="videoVolume * 100"></div>
                  </div>
                </div>

                <!-- Fullscreen Button -->
                <button class="btn btn-sm btn-dark m-0 p-1 rounded-5 d-flex align-items-center justify-content-center"
                  (click)="toggleFullscreen()" title="Toggle Fullscreen (F)">
                  <i class="bx fs-6 text-light" [class.bx-fullscreen]="!isFullscreen"
                    [class.bx-exit-fullscreen]="isFullscreen"></i>
                </button>
              </div>
            </div>

            <!-- Fullscreen overlay for better UX -->
            <div class="fullscreen-overlay" [class.show]="isFullscreen" (click)="togglePlayPause()">
              @if (!isVideoPlaying) {
              <div class="play-pause-overlay">
                <i class="bx bx-play-circle"></i>
              </div>
              }
            </div>
          </div>
        </div>

        <div class="col-6">
          <p class="fs-5 text-muted fw-bold">Notes :-</p>
          <div style="height: 250px; overflow-y:auto;" class="m-0 p-3 border rounded">
            <p>{{studentDetails.classVideoRecord.notes}}</p>
          </div>
        </div>
      </div>
    </div>
    }

  <script>

    this.setupFullscreenListener();
    // Video Player Methods
  playVideo(): void {
    this.showvideoContainer = true;
    // Allow some time for the video element to be rendered
    setTimeout(() => {
      if (this.videoPlayer?.nativeElement) {
        this.setupVideoEvents();
      }
    }, 100);
  }

  setupVideoEvents(): void {
    const video = this.videoPlayer.nativeElement;

    video.addEventListener('loadedmetadata', () => {
      this.videoDuration = video.duration;
    });

    video.addEventListener('timeupdate', () => {
      this.currentVideoTime = video.currentTime;
      this.updateVideoProgressBar();
    });

    video.addEventListener('play', () => {
      this.isVideoPlaying = true;
      this.startControlsAutoHide();
    });

    video.addEventListener('pause', () => {
      this.isVideoPlaying = false;
      this.showControls();
    });

    video.addEventListener('volumechange', () => {
      this.videoVolume = video.volume;
      this.isMuted = video.muted;
      this.updateVolumeProgressBar();
    });

    video.addEventListener('ended', () => {
      this.isVideoPlaying = false;
      this.showControls();
    });

    // Initialize progress bars
    setTimeout(() => {
      this.updateVideoProgressBar();
      this.updateVolumeProgressBar();
    }, 100);
  }

  updateVideoProgressBar(): void {
    if (this.videoRange?.nativeElement) {
      const progressOverlay = this.videoRange.nativeElement.parentElement?.querySelector('.progress-overlay') as HTMLElement;
      if (progressOverlay) {
        const percentage = this.getProgressPercentage();
        progressOverlay.style.width = `${percentage}%`;
      }
    }
  }

  updateVolumeProgressBar(): void {
    if (this.volumeRange?.nativeElement) {
      const progressOverlay = this.volumeRange.nativeElement.parentElement?.querySelector('.progress-overlay') as HTMLElement;
      if (progressOverlay) {
        const percentage = this.videoVolume * 100;
        progressOverlay.style.width = `${percentage}%`;
      }
    }
  }

  togglePlayPause(): void {
    const video = this.videoPlayer.nativeElement;
    if (this.isVideoPlaying) {
      video.pause();
    } else {
      video.play();
    }
    this.showControls();
  }

  seekVideo(event: Event): void {
    const input = event.target as HTMLInputElement;
    const video = this.videoPlayer.nativeElement;
    const seekTime = (parseFloat(input.value) / 100) * this.videoDuration;
    video.currentTime = seekTime;
    this.updateVideoProgressBar();
    this.showControls();
  }

  changeVolume(event: Event): void {
    const input = event.target as HTMLInputElement;
    const video = this.videoPlayer.nativeElement;
    const volume = parseFloat(input.value) / 100;
    video.volume = volume;
    this.videoVolume = volume;

    if (volume > 0) {
      this.videoPlayer.nativeElement.muted = false;
      this.isMuted = false;
    } else {
      this.videoPlayer.nativeElement.muted = true;
      this.isMuted = true;
    }

    this.updateVolumeProgressBar();
    this.showControls();
  }

  toggleMute(): void {
    const video = this.videoPlayer.nativeElement;
    video.muted = !video.muted;
    this.isMuted = video.muted;

    if (video.muted) {
      this.videoVolume = 0;
    } else {
      this.videoVolume = video.volume || 1;
      video.volume = this.videoVolume;
    }

    this.updateVolumeProgressBar();
    this.showControls();
  }

  // Fullscreen Methods
  showFullScreen(): void {
    const container = this.videoContainer.nativeElement;

    if (container.requestFullscreen) {
      container.requestFullscreen();
    } else if ((container as any).webkitRequestFullscreen) {
      (container as any).webkitRequestFullscreen();
    } else if ((container as any).msRequestFullscreen) {
      (container as any).msRequestFullscreen();
    } else if ((container as any).mozRequestFullScreen) {
      (container as any).mozRequestFullScreen();
    }
  }

  exitFullscreen(): void {
    if (document.exitFullscreen) {
      document.exitFullscreen();
    } else if ((document as any).webkitExitFullscreen) {
      (document as any).webkitExitFullscreen();
    } else if ((document as any).msExitFullscreen) {
      (document as any).msExitFullscreen();
    } else if ((document as any).mozCancelFullScreen) {
      (document as any).mozCancelFullScreen();
    }
  }

  toggleFullscreen(): void {
    if (this.isFullscreen) {
      this.exitFullscreen();
    } else {
      this.showFullScreen();
    }
    this.showControls();
  }

  setupFullscreenListener(): void {
    const handleFullscreenChange = () => {
      this.isFullscreen = !!(
        document.fullscreenElement ||
        (document as any).webkitFullscreenElement ||
        (document as any).msFullscreenElement ||
        (document as any).mozFullScreenElement
      );

      if (this.isFullscreen) {
        this.startControlsAutoHide();
      } else {
        this.showControls();
      }
    };

    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('msfullscreenchange', handleFullscreenChange);
    document.addEventListener('mozfullscreenchange', handleFullscreenChange);
  }

  // Control visibility methods
  showControls(): void {
    this.isControlsVisible = true;
    const controls = this.videoContainer?.nativeElement?.querySelector('.video-controls') as HTMLElement;
    if (controls) {
      controls.style.opacity = '1';
    }
    this.startControlsAutoHide();
  }

  hideControls(): void {
    if (this.isVideoPlaying && this.isFullscreen) {
      this.isControlsVisible = false;
      const controls = this.videoContainer?.nativeElement?.querySelector('.video-controls') as HTMLElement;
      if (controls) {
        controls.style.opacity = '0';
      }
    }
  }

  startControlsAutoHide(): void {
    if (this.controlsTimeout) {
      clearTimeout(this.controlsTimeout);
    }

    if (this.isVideoPlaying && this.isFullscreen) {
      this.controlsTimeout = setTimeout(() => {
        this.hideControls();
      }, 3000); // Hide after 3 seconds
    }
  }

  onMouseMove(): void {
    if (this.isFullscreen) {
      this.showControls();
    }
  }

  onVideoDoubleClick(): void {
    this.toggleFullscreen();
  }

  // Keyboard event handler
  @HostListener('document:keydown', ['$event'])
  handleKeyboardEvent(event: KeyboardEvent): void {
    if (this.showvideoContainer) {
      switch (event.key.toLowerCase()) {
        case 'f':
          event.preventDefault();
          this.toggleFullscreen();
          break;
        case 'escape':
          if (this.isFullscreen) {
            this.exitFullscreen();
          }
          break;
        case ' ':
          event.preventDefault();
          this.togglePlayPause();
          break;
        case 'm':
          event.preventDefault();
          this.toggleMute();
          break;
        case 'arrowleft':
          event.preventDefault();
          this.seekBackward();
          break;
        case 'arrowright':
          event.preventDefault();
          this.seekForward();
          break;
        case 'arrowup':
          event.preventDefault();
          this.volumeUp();
          break;
        case 'arrowdown':
          event.preventDefault();
          this.volumeDown();
          break;
      }
    }
  }

  // Additional control methods
  seekBackward(): void {
    const video = this.videoPlayer.nativeElement;
    video.currentTime = Math.max(0, video.currentTime - 10);
    this.showControls();
  }

  seekForward(): void {
    const video = this.videoPlayer.nativeElement;
    video.currentTime = Math.min(this.videoDuration, video.currentTime + 10);
    this.showControls();
  }

  volumeUp(): void {
    const video = this.videoPlayer.nativeElement;
    const newVolume = Math.min(1, video.volume + 0.1);
    video.volume = newVolume;
    this.videoVolume = newVolume;
    if (newVolume > 0) {
      video.muted = false;
      this.isMuted = false;
    }
    this.updateVolumeProgressBar();
    this.showControls();
  }

  volumeDown(): void {
    const video = this.videoPlayer.nativeElement;
    const newVolume = Math.max(0, video.volume - 0.1);
    video.volume = newVolume;
    this.videoVolume = newVolume;
    if (newVolume === 0) {
      video.muted = true;
      this.isMuted = true;
    }
    this.updateVolumeProgressBar();
    this.showControls();
  }

  closeVideo(): void {
    if (this.isFullscreen) {
      this.exitFullscreen();
    }

    if (this.controlsTimeout) {
      clearTimeout(this.controlsTimeout);
    }

    this.showvideoContainer = false;
    this.isVideoPlaying = false;
    this.currentVideoTime = 0;
    this.isControlsVisible = true;
  }

  // Utility methods
  formatTime(seconds: number): string {
    if (isNaN(seconds) || seconds < 0) return '0:00';

    const hours = Math.floor(seconds / 3600);
    const minutes = Math.floor((seconds % 3600) / 60);
    const secs = Math.floor(seconds % 60);

    if (hours > 0) {
      return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
    } else {
      return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
  }

  getProgressPercentage(): number {
    return this.videoDuration > 0 ? (this.currentVideoTime / this.videoDuration) * 100 : 0;
  }

  // Download methods (keeping your existing download functionality)
  download(studyMaterial?: any): void {
    try {
      const material = studyMaterial || this.StudyMaterial;

      if (!material || !material.documents) {
        console.error('No document found in study material');
        this.showNotification('No document available for download', 'error');
        return;
      }

      const document = material.documents;

      if (!document.documentContent && !document.documentContant) {
        console.error('Document content is missing');
        this.showNotification('Document content is missing', 'error');
        return;
      }

      const documentContent = document.documentContent || document.documentContant;
      const base64Data = documentContent.split(',')[1];
      const byteCharacters = atob(base64Data);
      const byteNumbers = new Array(byteCharacters.length);

      for (let i = 0; i < byteCharacters.length; i++) {
        byteNumbers[i] = byteCharacters.charCodeAt(i);
      }

      const byteArray = new Uint8Array(byteNumbers);
      const mimeType = document.documentsExtention || document.documentsExtension || 'application/pdf';
      const blob = new Blob([byteArray], { type: mimeType });

      const url = window.URL.createObjectURL(blob);
      const link = window.document.createElement('a');
      link.href = url;
      link.download = document.documentName || 'study-material.pdf';

      window.document.body.appendChild(link);
      link.click();

      window.document.body.removeChild(link);
      window.URL.revokeObjectURL(url);

      console.log(`Downloaded: ${document.documentName}`);
      this.showNotification(`Downloaded: ${document.documentName}`, 'success');

    } catch (error) {
      console.error('Error downloading file:', error);
      this.showNotification('Failed to download file', 'error');
    }
  }

  downloadAll(): void {
    if (Array.isArray(this.StudyMaterial)) {
      this.StudyMaterial.forEach((material: any, index: number) => {
        setTimeout(() => {
          this.download(material);
        }, index * 100);
      });
    } else {
      this.download();
    }
  }

  private showNotification(message: string, type: 'success' | 'error'): void {
    console.log(`${type.toUpperCase()}: ${message}`);
    // You can implement a toast notification service here
  }

  canDownload(studyMaterial?: any): boolean {
    const material = studyMaterial || this.StudyMaterial;
    return !!(material?.documents?.documentContent || material?.documents?.documentContant);
  }

  // Component cleanup
  ngOnDestroy(): void {
    if (this.controlsTimeout) {
      clearTimeout(this.controlsTimeout);
    }

    if (this.isFullscreen) {
      this.exitFullscreen();
    }
  }
  </script>
</body>
</html>
